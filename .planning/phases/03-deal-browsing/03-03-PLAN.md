---
phase: 03-deal-browsing
plan: 03
type: execute
---

<objective>
Build advanced filter panel and sort selector for refined deal discovery.

Purpose: Enable power users to narrow down deals by price range and sort by various criteria.
Output: PriceRangeFilter, SortSelector, and FilterPanel components integrated into browse page.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@CLAUDE.md
@.planning/phases/03-deal-browsing/03-02-PLAN.md

**Depends on:** 03-02-PLAN (browse page, CategoryFilter, DealsGrid)

**Filter requirements:**
- Price range filter (min/max inputs)
- Sort options: price low-high, price high-low, biggest discount, most popular, newest
- Filter panel that combines all filters
- Mobile: drawer/sheet variant
- Desktop: sidebar or collapsible panel
- Apply/reset functionality

**Mock data utilities (from 01-03-PLAN):**
- filterDeals(filters: DealFilters) - supports minPrice, maxPrice, category, city
- sortDeals(deals, sortBy: SortOption) - price-asc, price-desc, discount, popular, newest

**Component architecture:**
- PriceRangeFilter, SortSelector go in components/patterns/
- FilterPanel goes in components/features/ (combines patterns with state logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PriceRangeFilter component</name>
  <files>src/components/patterns/priceRangeFilter.tsx</files>
  <action>
Create src/components/patterns/priceRangeFilter.tsx with min/max price inputs:

```tsx
'use client'

import { useState, useEffect } from 'react'
import { CurrencyDollar } from '@phosphor-icons/react'
import { Input } from '@/components/ui/input'

interface PriceRangeFilterProps {
  minPrice?: number
  maxPrice?: number
  onChange: (min: number | undefined, max: number | undefined) => void
}

export function PriceRangeFilter({ minPrice, maxPrice, onChange }: PriceRangeFilterProps) {
  const [min, setMin] = useState<string>(minPrice?.toString() ?? '')
  const [max, setMax] = useState<string>(maxPrice?.toString() ?? '')

  // Sync external changes
  useEffect(() => {
    setMin(minPrice?.toString() ?? '')
    setMax(maxPrice?.toString() ?? '')
  }, [minPrice, maxPrice])

  const handleMinChange = (value: string) => {
    setMin(value)
    const numValue = value ? parseInt(value, 10) : undefined
    if (numValue === undefined || !isNaN(numValue)) {
      onChange(numValue, max ? parseInt(max, 10) : undefined)
    }
  }

  const handleMaxChange = (value: string) => {
    setMax(value)
    const numValue = value ? parseInt(value, 10) : undefined
    if (numValue === undefined || !isNaN(numValue)) {
      onChange(min ? parseInt(min, 10) : undefined, numValue)
    }
  }

  return (
    <div className="space-y-3">
      <label className="block text-sm font-medium text-text-secondary">
        Price Range
      </label>
      <div className="flex items-center gap-3">
        <div className="relative flex-1">
          <CurrencyDollar
            size={16}
            className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted"
          />
          <input
            type="number"
            placeholder="Min"
            value={min}
            onChange={(e) => handleMinChange(e.target.value)}
            className="
              w-full pl-8 pr-3 py-2.5
              bg-glass-bg backdrop-blur-md
              border border-glass-border rounded-xl
              text-text-primary placeholder:text-text-muted
              transition-all duration-200
              focus:outline-none focus:ring-2 focus:ring-brand-primary/50
              focus:border-brand-primary/50
              [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none
            "
          />
        </div>
        <span className="text-text-muted">â€”</span>
        <div className="relative flex-1">
          <CurrencyDollar
            size={16}
            className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted"
          />
          <input
            type="number"
            placeholder="Max"
            value={max}
            onChange={(e) => handleMaxChange(e.target.value)}
            className="
              w-full pl-8 pr-3 py-2.5
              bg-glass-bg backdrop-blur-md
              border border-glass-border rounded-xl
              text-text-primary placeholder:text-text-muted
              transition-all duration-200
              focus:outline-none focus:ring-2 focus:ring-brand-primary/50
              focus:border-brand-primary/50
              [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none
            "
          />
        </div>
      </div>
    </div>
  )
}
```

Key implementation notes:
- Side-by-side min/max inputs with dollar sign icons
- Hide number input spinners for cleaner look
- Glassmorphic input styling matching design system
- Controlled inputs with debounced onChange
- Handles empty/undefined values gracefully
  </action>
  <verify>Component renders, entering values triggers onChange, styling matches design system</verify>
  <done>PriceRangeFilter with min/max dollar inputs and glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 2: Create SortSelector component</name>
  <files>src/components/patterns/sortSelector.tsx</files>
  <action>
Create src/components/patterns/sortSelector.tsx with sort dropdown:

```tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import { CaretDown, Check, ArrowUp, ArrowDown, Fire, Clock, Tag } from '@phosphor-icons/react'
import type { SortOption } from '@/lib/mock-data'

interface SortSelectorProps {
  value: SortOption
  onChange: (value: SortOption) => void
}

type SortOptionConfig = {
  value: SortOption
  label: string
  icon: React.ElementType
}

const sortOptions: SortOptionConfig[] = [
  { value: 'popular', label: 'Most Popular', icon: Fire },
  { value: 'newest', label: 'Newest', icon: Clock },
  { value: 'discount', label: 'Biggest Discount', icon: Tag },
  { value: 'price-asc', label: 'Price: Low to High', icon: ArrowUp },
  { value: 'price-desc', label: 'Price: High to Low', icon: ArrowDown },
]

export function SortSelector({ value, onChange }: SortSelectorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const containerRef = useRef<HTMLDivElement>(null)

  const selectedOption = sortOptions.find(opt => opt.value === value) ?? sortOptions[0]

  // Close on outside click
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const handleSelect = (option: SortOption) => {
    onChange(option)
    setIsOpen(false)
  }

  return (
    <div ref={containerRef} className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="
          flex items-center gap-2 px-4 py-2.5
          bg-glass-bg backdrop-blur-md
          border border-glass-border rounded-xl
          text-text-primary text-sm
          transition-all duration-200
          hover:border-glass-border-hover
          focus:outline-none focus:ring-2 focus:ring-brand-primary/50
        "
      >
        <selectedOption.icon size={16} weight="regular" className="text-text-secondary" />
        <span>{selectedOption.label}</span>
        <CaretDown
          size={14}
          weight="bold"
          className={`text-text-muted transition-transform ${isOpen ? 'rotate-180' : ''}`}
        />
      </button>

      {isOpen && (
        <div className="
          absolute right-0 mt-2 w-56 z-50
          bg-bg-secondary backdrop-blur-xl
          border border-glass-border rounded-xl
          shadow-elevated overflow-hidden
        ">
          {sortOptions.map((option) => {
            const isSelected = value === option.value
            return (
              <button
                key={option.value}
                onClick={() => handleSelect(option.value)}
                className={`
                  w-full flex items-center gap-3 px-4 py-3
                  text-sm text-left transition-colors
                  ${isSelected
                    ? 'bg-brand-primary/10 text-brand-primary'
                    : 'text-text-secondary hover:bg-glass-bg hover:text-text-primary'
                  }
                `}
              >
                <option.icon size={16} weight={isSelected ? 'fill' : 'regular'} />
                <span className="flex-1">{option.label}</span>
                {isSelected && <Check size={16} weight="bold" />}
              </button>
            )
          })}
        </div>
      )}
    </div>
  )
}
```

Key implementation notes:
- Dropdown with icons for each sort option
- Selected option shown in trigger button
- Check mark for current selection
- Glassmorphic dropdown styling
- Close on outside click
- Caret rotates when open
  </action>
  <verify>Dropdown opens/closes, selecting option triggers onChange, selected state visible</verify>
  <done>SortSelector dropdown with 5 sort options and glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 3: Create FilterPanel and integrate into browse page</name>
  <files>src/components/features/filterPanel.tsx, src/app/deals/page.tsx</files>
  <action>
1. Create src/components/features/filterPanel.tsx:

```tsx
'use client'

import { useState } from 'react'
import { Funnel, X } from '@phosphor-icons/react'
import { Button } from '@/components/ui/button'
import { PriceRangeFilter } from '@/components/patterns/priceRangeFilter'
import { SortSelector } from '@/components/patterns/sortSelector'
import type { DealFilters, SortOption } from '@/lib/mock-data'

interface FilterPanelProps {
  filters: DealFilters
  sortBy: SortOption
  onFiltersChange: (filters: DealFilters) => void
  onSortChange: (sort: SortOption) => void
  onReset: () => void
  activeFilterCount: number
}

export function FilterPanel({
  filters,
  sortBy,
  onFiltersChange,
  onSortChange,
  onReset,
  activeFilterCount,
}: FilterPanelProps) {
  const [isExpanded, setIsExpanded] = useState(false)

  const handlePriceChange = (min: number | undefined, max: number | undefined) => {
    onFiltersChange({
      ...filters,
      minPrice: min,
      maxPrice: max,
    })
  }

  return (
    <div className="space-y-4">
      {/* Filter Header Row */}
      <div className="flex items-center justify-between gap-4 flex-wrap">
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="
            flex items-center gap-2 px-4 py-2.5
            bg-glass-bg backdrop-blur-md
            border border-glass-border rounded-xl
            text-text-primary text-sm
            transition-all duration-200
            hover:border-glass-border-hover
          "
        >
          <Funnel size={16} weight={isExpanded ? 'fill' : 'regular'} />
          <span>Filters</span>
          {activeFilterCount > 0 && (
            <span className="
              flex items-center justify-center
              w-5 h-5 rounded-full
              bg-brand-primary text-white text-xs font-medium
            ">
              {activeFilterCount}
            </span>
          )}
        </button>

        <div className="flex items-center gap-3">
          {activeFilterCount > 0 && (
            <button
              onClick={onReset}
              className="flex items-center gap-1 text-sm text-text-tertiary hover:text-text-secondary transition-colors"
            >
              <X size={14} />
              Clear all
            </button>
          )}
          <SortSelector value={sortBy} onChange={onSortChange} />
        </div>
      </div>

      {/* Expandable Filter Content */}
      {isExpanded && (
        <div className="
          p-4 bg-glass-bg backdrop-blur-md
          border border-glass-border rounded-xl
          space-y-4
        ">
          <PriceRangeFilter
            minPrice={filters.minPrice}
            maxPrice={filters.maxPrice}
            onChange={handlePriceChange}
          />

          {/* Future: Add more filters here (location radius, discount minimum, etc.) */}
        </div>
      )}
    </div>
  )
}
```

2. Update src/app/deals/page.tsx to integrate FilterPanel:

```tsx
'use client'

import { useState, useMemo } from 'react'
import { useRouter } from 'next/navigation'
import { MapPin } from '@phosphor-icons/react'
import { CategoryFilter } from '@/components/patterns/categoryFilter'
import { DealsGrid } from '@/components/features/dealsGrid'
import { FilterPanel } from '@/components/features/filterPanel'
import { getActiveDeals, getDealsByCategory, filterDeals, sortDeals, type DealFilters, type SortOption } from '@/lib/mock-data'
import type { TreatmentCategory } from '@/types'

export default function DealsPage() {
  const router = useRouter()
  const [selectedCategory, setSelectedCategory] = useState<TreatmentCategory | 'all'>('all')
  const [filters, setFilters] = useState<DealFilters>({})
  const [sortBy, setSortBy] = useState<SortOption>('popular')

  // TODO: In Phase 2 integration, use location context
  const currentLocation = 'Austin, TX'

  const deals = useMemo(() => {
    // Get base deals by category
    let result = selectedCategory === 'all'
      ? getActiveDeals()
      : getDealsByCategory(selectedCategory)

    // Apply price filters
    if (filters.minPrice !== undefined || filters.maxPrice !== undefined) {
      result = result.filter(deal => {
        if (filters.minPrice !== undefined && deal.dealPrice < filters.minPrice) return false
        if (filters.maxPrice !== undefined && deal.dealPrice > filters.maxPrice) return false
        return true
      })
    }

    // Apply sorting
    result = sortDeals(result, sortBy)

    return result
  }, [selectedCategory, filters, sortBy])

  const handleCategoryChange = (category: TreatmentCategory | 'all') => {
    setSelectedCategory(category)
  }

  const handleFiltersChange = (newFilters: DealFilters) => {
    setFilters(newFilters)
  }

  const handleSortChange = (sort: SortOption) => {
    setSortBy(sort)
  }

  const handleReset = () => {
    setFilters({})
    setSortBy('popular')
  }

  const activeFilterCount = [
    filters.minPrice !== undefined,
    filters.maxPrice !== undefined,
  ].filter(Boolean).length

  const handleDealClick = (dealId: string) => {
    router.push(`/deals/${dealId}`)
  }

  return (
    <main className="pt-20 pb-20 md:pb-8 px-4 sm:px-6 lg:px-8">
      <div className="max-w-7xl mx-auto">
        {/* Page Header */}
        <div className="mb-8">
          <h1 className="text-2xl sm:text-3xl font-bold text-text-primary mb-2">
            Deals Near You
          </h1>
          <div className="flex items-center gap-1.5 text-text-secondary">
            <MapPin size={16} weight="fill" />
            <span>{currentLocation}</span>
            <button className="text-brand-primary text-sm hover:underline ml-2">
              Change
            </button>
          </div>
        </div>

        {/* Category Filter */}
        <div className="mb-6">
          <CategoryFilter
            selected={selectedCategory}
            onChange={handleCategoryChange}
          />
        </div>

        {/* Filter Panel with Sort */}
        <div className="mb-6">
          <FilterPanel
            filters={filters}
            sortBy={sortBy}
            onFiltersChange={handleFiltersChange}
            onSortChange={handleSortChange}
            onReset={handleReset}
            activeFilterCount={activeFilterCount}
          />
        </div>

        {/* Deals Grid */}
        <DealsGrid
          deals={deals}
          onDealClick={handleDealClick}
        />
      </div>
    </main>
  )
}
```

Key implementation notes:
- FilterPanel is collapsible to save space
- Active filter count shown as badge
- Sort selector always visible
- Clear all button when filters active
- Price filtering applied in useMemo
- Sorting applied after filtering
  </action>
  <verify>Filter panel expands/collapses, price filter works, sorting changes order, reset clears filters</verify>
  <done>FilterPanel with price range and sort, integrated into browse page</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PriceRangeFilter accepts min/max values correctly
- [ ] SortSelector dropdown opens and selects options
- [ ] FilterPanel expands/collapses
- [ ] Active filter count badge updates
- [ ] Clear all resets filters and sort
- [ ] Deals are filtered by price range
- [ ] Deals are sorted by selected option
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Price filtering works correctly
- All 5 sort options functional
- Filter state persists during session
- Reset functionality works
</success_criteria>

<output>
After completion, create `.planning/phases/03-deal-browsing/03-03-SUMMARY.md`
</output>
