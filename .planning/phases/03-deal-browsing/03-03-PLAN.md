---
phase: 03-deal-browsing
plan: 03
type: execute
---

<objective>
Build advanced filter panel and sort selector for refined deal discovery.

Purpose: Enable power users to narrow down deals by price range and sort by various criteria.
Output: PriceRangeFilter, SortSelector, and FilterPanel components integrated into browse page.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@CLAUDE.md

**Prior Phase Summaries:**
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/03-deal-browsing/03-02-PLAN.md

**Depends on:** 03-02-PLAN (browse page, CategoryFilter, DealsGrid)

**Filter requirements:**
- Price range filter (min/max inputs)
- Sort options: price low-high, price high-low, biggest discount, most popular, newest
- Filter panel that combines all filters
- Collapsible panel to save screen space
- Apply/reset functionality

**Mock data utilities from Phase 1-03:**
- filterDeals(filters: DealFilters) - supports minPrice, maxPrice, category, city, minDiscount
- sortDeals(deals, sortBy: SortOption) - 'price-asc', 'price-desc', 'discount', 'popular', 'newest'
- Types: DealFilters, SortOption already exported from @/lib/mock-data

**Component architecture:**
- PriceRangeFilter, SortSelector go in components/patterns/ (reusable)
- FilterPanel goes in components/features/ (combines patterns with state logic)

**Design system:**
- Use glassmorphic inputs (no Input component exists for number, use native with styling)
- Dropdown styling: bg-bg-secondary backdrop-blur-xl border border-glass-border rounded-xl shadow-elevated
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PriceRangeFilter component</name>
  <files>src/components/patterns/priceRangeFilter.tsx</files>
  <action>
Create src/components/patterns/priceRangeFilter.tsx with min/max price inputs.

'use client' for controlled inputs.

Props interface:
- minPrice?: number
- maxPrice?: number
- onChange: (min: number | undefined, max: number | undefined) => void

Internal state:
- min: string (for controlled input)
- max: string (for controlled input)

Structure:
1. Label: "Price Range" in text-sm font-medium text-text-secondary
2. Two inputs side by side with "â€”" separator:
   - Each input: relative flex-1
   - CurrencyDollar icon (Phosphor) positioned absolute left
   - Native number input styled:
     - w-full pl-8 pr-3 py-2.5
     - bg-glass-bg backdrop-blur-md
     - border border-glass-border rounded-xl
     - text-text-primary placeholder:text-text-muted
     - focus:outline-none focus:ring-2 focus:ring-brand-primary/50 focus:border-brand-primary/50
     - Hide spinners: [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none
   - Placeholder: "Min" / "Max"

useEffect to sync external props changes to internal state.
Parse to number on change, call onChange with undefined for empty values.
  </action>
  <verify>Component renders, entering values triggers onChange with correct number values</verify>
  <done>PriceRangeFilter with min/max dollar inputs and glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 2: Create SortSelector component</name>
  <files>src/components/patterns/sortSelector.tsx</files>
  <action>
Create src/components/patterns/sortSelector.tsx with sort dropdown.

'use client' for dropdown state.

Props interface:
- value: SortOption (import from @/lib/mock-data)
- onChange: (value: SortOption) => void

Sort options with icons:
- { value: 'popular', label: 'Most Popular', icon: Fire }
- { value: 'newest', label: 'Newest', icon: Clock }
- { value: 'discount', label: 'Biggest Discount', icon: Tag }
- { value: 'price-asc', label: 'Price: Low to High', icon: ArrowUp }
- { value: 'price-desc', label: 'Price: High to Low', icon: ArrowDown }

Internal state:
- isOpen: boolean

Structure:
1. Trigger button:
   - flex items-center gap-2 px-4 py-2.5
   - bg-glass-bg backdrop-blur-md border border-glass-border rounded-xl
   - Selected option icon + label
   - CaretDown icon (rotates when open)

2. Dropdown (when isOpen):
   - absolute right-0 mt-2 w-56 z-50
   - bg-bg-secondary backdrop-blur-xl border border-glass-border rounded-xl shadow-elevated
   - Option buttons:
     - w-full flex items-center gap-3 px-4 py-3
     - Selected: bg-brand-primary/10 text-brand-primary
     - Unselected: text-text-secondary hover:bg-glass-bg hover:text-text-primary
     - Check icon for selected option

Close on outside click using useRef and useEffect with mousedown listener.
  </action>
  <verify>Dropdown opens/closes, selecting option triggers onChange, selected state visible</verify>
  <done>SortSelector dropdown with 5 sort options and glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 3: Create FilterPanel and integrate into browse page</name>
  <files>src/components/features/filterPanel.tsx, src/app/deals/page.tsx</files>
  <action>
1. Create src/components/features/filterPanel.tsx:

'use client' for state.

Props interface:
- filters: DealFilters (from @/lib/mock-data)
- sortBy: SortOption (from @/lib/mock-data)
- onFiltersChange: (filters: DealFilters) => void
- onSortChange: (sort: SortOption) => void
- onReset: () => void
- activeFilterCount: number

Internal state:
- isExpanded: boolean (default false)

Structure:
1. Header row (flex items-center justify-between gap-4 flex-wrap):
   - Filter toggle button:
     - Funnel icon (filled when expanded)
     - "Filters" text
     - Badge with activeFilterCount (if > 0): bg-brand-primary text-white rounded-full
   - Right side:
     - Clear all button (if activeFilterCount > 0): X icon + "Clear all"
     - SortSelector

2. Expandable content (when isExpanded):
   - Container: p-4 bg-glass-bg backdrop-blur-md border border-glass-border rounded-xl space-y-4
   - PriceRangeFilter

handlePriceChange: merge new min/max into filters and call onFiltersChange.

2. Update src/app/deals/page.tsx:

Add new state:
- filters: DealFilters (default {})
- sortBy: SortOption (default 'popular')

Add handlers:
- handleFiltersChange: update filters state
- handleSortChange: update sortBy state
- handleReset: reset filters to {}, sortBy to 'popular'

Calculate activeFilterCount:
- Count truthy values: filters.minPrice, filters.maxPrice

Update useMemo for deals:
1. Get base deals (by category)
2. Apply city filter if locationState.city set
3. Apply price filters inline if minPrice/maxPrice set
4. Apply sortDeals(result, sortBy)

Add FilterPanel between CategoryFilter and DealsGrid:
- Pass filters, sortBy, handlers, activeFilterCount
  </action>
  <verify>Filter panel expands/collapses, price filter works, sorting changes order, reset clears filters</verify>
  <done>FilterPanel with price range and sort, integrated into browse page</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PriceRangeFilter accepts min/max values correctly
- [ ] SortSelector dropdown opens and selects options
- [ ] FilterPanel expands/collapses
- [ ] Active filter count badge updates
- [ ] Clear all resets filters and sort
- [ ] Deals are filtered by price range
- [ ] Deals are sorted by selected option
- [ ] All filters work together with category and location
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Price filtering works correctly
- All 5 sort options functional
- Filter state persists during session
- Reset functionality works
- Filters combine correctly with category and location
</success_criteria>

<output>
After completion, create `.planning/phases/03-deal-browsing/03-03-SUMMARY.md`
</output>
